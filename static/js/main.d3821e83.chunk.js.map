{"version":3,"sources":["Redux/Actions.js","Components/DateMenu.js","Components/TemperatureBlock.js","Components/Map.js","Components/ServerRequest.js","Redux/Saga.js","App.js","Redux/Reducer.js","serviceWorker.js","index.js"],"names":["c","CHANGE_VIEWPORT","CHANGE_SELECTED_DATE","UPDATE_WEATHER_DATA","FETCH_WEATHER_DATA","DateMenu","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","buttons","opened","_this2","setState","react_default","a","createElement","key","className","data-day","data-word","onClick","el","setDate","changeSelectedDate","target","dataset","day","word","closeMenu","style","position","left","top","bind","openMenu","react_addons_css_transition_group_default","transitionName","transitionAppear","transitionEnterTimeout","transitionEnter","transitionLeaveTimeout","transitionLeave","Component","connect","store","dispatch","newDay","newWord","type","selectedDayForWeather","selectedWordForWeather","TemperatureBlock","temperature","undefined","length","dayForWeather","main","temp","wordForWeather","place","weatherData","city","name","list","Map","onViewportChange","viewport","console","log","zoom","changeViewport","objectSpread","lastTime","Date","now","mapDiv","React","createRef","mapRef","setProperSize","window","addEventListener","getLocation","fetchWeatherData","prevProps","latitude","longitude","setTimeout","navigator","geolocation","getCurrentPosition","coords","width","current","offsetWidth","height","offsetHeight","ref","esm","assign","mapboxApiAccessToken","Components_TemperatureBlock","Components_DateMenu","dist_default","changedViewport","getWeather","lat","lon","fetch","concat","method","headers","content-type","accept","mode","then","result","json","watchFetchWeatherData","fetchWeatherDataAsync","regenerator_default","wrap","_context","prev","next","takeLatest","stop","_marked","data","_context2","select","sent","put","t0","_marked2","sagaMiddleware","createSagaMiddleware","createStore","oldState","action","applyMiddleware","run","App","es","Components_Map","Boolean","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.d3821e83.chunk.js","sourcesContent":["//типы забиты в константы, чтобы труднее было ошибиться при вводе \r\nexport const c = {\r\n    CHANGE_VIEWPORT: \"CHANGE_VIEWPORT\",\r\n    CHANGE_SELECTED_DATE: \"CHANGE_SELECTED_DATE\",\r\n    UPDATE_WEATHER_DATA: \"UPDATE_WEATHER_DATA\",\r\n    FETCH_WEATHER_DATA: \"FETCH_WEATHER_DATA\",\r\n};\r\n\r\nexport const changeViewport = (changedViewport) => {\r\n    return {\r\n        type: c.CHANGE_VIEWPORT,\r\n        viewport: changedViewport,\r\n    };\r\n};\r\n\r\nexport const changeSelectedDate = (newDay, newWord) => {\r\n    return {\r\n        type: c.CHANGE_SELECTED_DATE,\r\n        selectedDayForWeather: newDay,\r\n        selectedWordForWeather: newWord,\r\n    };\r\n};\r\n\r\n// export const updateWeatherData = (newData) => {\r\n//     return {\r\n//         type: c.UPDATE_WEATHER_DATA,\r\n//         weatherData: newData,\r\n//     };\r\n// };\r\n\r\nexport const fetchWeatherData = () => {\r\n    return {\r\n        type: c.FETCH_WEATHER_DATA,\r\n    };\r\n};","import React, { Component } from 'react';\r\nimport ReactCSSTransitionGroup from 'react-addons-css-transition-group';\r\nimport { connect } from 'react-redux';\r\nimport { changeSelectedDate } from \"../Redux/Actions\";\r\n\r\n\r\nclass DateMenu extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            buttons: [],\r\n            opened: false,\r\n        };\r\n    };\r\n\r\n\r\n    //при нажатии на кнопку с меню выбора даты в массив кнопок добавляются элементы\r\n    //аниматор реакта реагирует на появление элементов и запускает анимацию появления\r\n    //так же указывается, что состояние меню \"открыто\"\r\n    openMenu() {\r\n\r\n        this.setState({\r\n            buttons: [\r\n                <button key=\"1\" className=\"buttonMain\" data-day=\"0\" data-word=\"today\" onClick={el => this.setDate(el)}> Today </button>,\r\n                <button key=\"2\" className=\"buttonMain\" data-day=\"1\" data-word=\"tomorrow\" onClick={el => this.setDate(el)}> Tomorrow </button>,\r\n                <button key=\"3\" className=\"buttonMain\" data-day=\"2\" data-word=\"the day after tomorrow\" onClick={el => this.setDate(el)}> The day after tomorrow </button>\r\n            ],\r\n            opened: true,\r\n        });\r\n    };\r\n\r\n\r\n    //при выборе какого-либо дня этот день идёт в стор, меню закрывается\r\n    setDate(el) {\r\n\r\n        this.props.changeSelectedDate(el.target.dataset.day, el.target.dataset.word)\r\n        this.closeMenu();\r\n    };\r\n\r\n\r\n    //аниматор реакта реагирует на удаление элементов в массиве и запускает анимацию исчезновения\r\n    //так же указывается, что состояние меню \"закрыто\"\r\n    closeMenu() {\r\n\r\n        this.setState({\r\n            buttons: [],\r\n            opened: false,\r\n        });\r\n    };\r\n\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"daySelector\" style={{ position: 'absolute', left: 10, top: 190 }}>\r\n                <button className=\"buttonMain\"\r\n                    onClick={(!this.state.opened) ? this.openMenu.bind(this) : this.closeMenu.bind(this)}> Choose date </button>\r\n                <ReactCSSTransitionGroup transitionName=\"anim\" transitionAppear={false} transitionEnterTimeout={500} transitionEnter={true} transitionLeaveTimeout={500} transitionLeave={true}>\r\n                    {this.state.buttons}\r\n                </ReactCSSTransitionGroup>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n//получение из стора нужных в данном компоненте элементов. они придут через пропсы в этот компонент\r\nconst getDataFromStore = store => ({\r\n})\r\n\r\n//создание экшенов, которые нужны в этом компоненте. они придут сюда через пропсы.\r\nconst setDataToStore = dispatch => ({\r\n\r\n    changeSelectedDate: (newDay, newWord) => dispatch(changeSelectedDate(newDay, newWord)),\r\n})\r\n\r\nexport default connect(getDataFromStore, setDataToStore)(DateMenu);","import React, { Component } from 'react';\r\nimport { connect } from 'react-redux';\r\n\r\n\r\nclass TemperatureBlock extends Component {\r\n\r\n    render() {       \r\n\r\n        let temperature = undefined;\r\n\r\n        //сразу проверка на то, что массив загружен \r\n        //потом, в зависимости от выбранного дня, показывается температура\r\n        //сервер присылает в ответе погоду на 5 дней, на каждые 3 часа. \r\n        //погода показывается на ближайшее время на сегодня и на это же время завтра\\послезавтра\r\n\r\n        if (this.props.temperature.length !== 0) {            \r\n            switch (+this.props.dayForWeather) {\r\n                \r\n                case 1: {\r\n                    temperature = this.props.temperature[8].main.temp;\r\n                    break;\r\n                }\r\n                case 2: {\r\n                    temperature = this.props.temperature[16].main.temp;\r\n                    break;\r\n                }\r\n                default: {\r\n                    temperature = this.props.temperature[0].main.temp;\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n       \r\n        return (\r\n            <div className=\"temperatureDiv\" style={{ position: 'absolute', left: 10, top: 110 }}>\r\n                <label>{\"Temperature for \" + this.props.wordForWeather}</label>\r\n                <label>{\"in \" + this.props.place}</label>\r\n                <label>{\"is \" + temperature + \" degrees Celsius\"}</label>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n//получение из стора нужных в данном компоненте элементов. они придут через пропсы в этот компонент\r\nconst getDataFromStore = store => ({\r\n    wordForWeather: store.selectedWordForWeather,    \r\n    dayForWeather: store.selectedDayForWeather,\r\n    place: store.weatherData.city.name, \r\n    temperature: store.weatherData.list,    \r\n})\r\n\r\n//создание экшенов, которые нужны в этом компоненте. они придут сюда через пропсы.\r\nconst setDataToStore = dispatch => ({\r\n})\r\n\r\nexport default connect(getDataFromStore, setDataToStore)(TemperatureBlock);","import React, { Component } from 'react';\r\nimport ReactMapGL, { NavigationControl } from 'react-map-gl';\r\nimport Geocoder from \"react-map-gl-geocoder\";\r\nimport { connect } from 'react-redux';\r\nimport { changeViewport, fetchWeatherData } from \"../Redux/Actions\";\r\nimport DateMenu from \"./DateMenu\";\r\nimport TemperatureBlock from \"./TemperatureBlock\";\r\n\r\n\r\nclass Map extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.mapDiv = React.createRef();\r\n    this.mapRef = React.createRef();\r\n\r\n    this.state = {\r\n      lastTime: Date.now(),\r\n    };\r\n  };\r\n\r\n  //в начале определяется размер экрана, чтобы растянуть карту, геопозиция пользователя и погода в этом месте\r\n  componentDidMount() {\r\n\r\n    this.setProperSize();\r\n    window.addEventListener(\"resize\", this.setProperSize.bind(this));\r\n\r\n    this.getLocation();\r\n\r\n    this.props.fetchWeatherData();\r\n  };\r\n\r\n  //если в пропсах поменялись координаты, то запускается неблоьшой таймер, после идет проверка на давность изменений координат.\r\n  //если пользщователь перестал перемещаться по карте (200мс не делал ничего), то с сервера запрашивается информация о погоде и метсности по координатам\r\n  componentDidUpdate(prevProps) {\r\n\r\n    if (this.props.viewport.latitude !== prevProps.viewport.latitude || this.props.viewport.longitude !== prevProps.viewport.longitude) {\r\n      setTimeout(checkLastUpdate.bind(this), 200);\r\n    };\r\n\r\n    function checkLastUpdate() {\r\n      if ((this.state.lastTime + 199) < Date.now()) {\r\n        this.props.fetchWeatherData();\r\n      };\r\n    };\r\n  };\r\n\r\n  //запрашивается геопозиция пользователя и отправляется в стор, чтобы сразу показывалась температура рядом\r\n  getLocation() {\r\n\r\n    if (navigator.geolocation) {\r\n      navigator.geolocation.getCurrentPosition(\r\n        (position) => this.props.changeViewport({ ...this.props.viewport, latitude: position.coords.latitude, longitude: position.coords.longitude })\r\n      );\r\n    };\r\n    this.props.fetchWeatherData();\r\n  };\r\n\r\n  //обновление в сторе размера экрана\r\n  setProperSize() {\r\n    this.props.changeViewport({ ...this.props.viewport, width: this.mapDiv.current.offsetWidth, height: this.mapDiv.current.offsetHeight });\r\n  };\r\n\r\n  //при смене позиции на карте записывается дата последнего изменения позиции и обновляются в сторе координаты\r\n  onViewportChange = viewport => {\r\n    console.log(this.props.viewport.zoom, viewport.zoom)\r\n    this.props.changeViewport({ ...this.props.viewport, ...viewport });\r\n    this.setState({\r\n      lastTime: Date.now(),\r\n    });\r\n  };\r\n\r\n\r\n  render() {\r\n\r\n    return (\r\n      <div ref={this.mapDiv} className=\"mapDiv\">\r\n        <ReactMapGL\r\n          ref={this.mapRef}\r\n          mapboxApiAccessToken={\"pk.eyJ1IjoiZWFrdGhlY2F0IiwiYSI6ImNqbmFzZXd6MjAweGEza3A4cnZrNHZraXQifQ.cIbSGmYxwZOc2sNnxZ0hsQ\"}\r\n          {...this.props.viewport}\r\n          onViewportChange={this.onViewportChange} >\r\n          <div style={{ position: 'absolute', left: 10, top: 10 }}>\r\n            <NavigationControl\r\n              onViewportChange={this.onViewportChange}\r\n            />\r\n          </div>\r\n          <TemperatureBlock />\r\n          <DateMenu />\r\n          <div>\r\n            <Geocoder mapRef={this.mapRef}\r\n              onViewportChange={this.onViewportChange}\r\n              mapboxApiAccessToken={\"pk.eyJ1IjoiZWFrdGhlY2F0IiwiYSI6ImNqbmFzZXd6MjAweGEza3A4cnZrNHZraXQifQ.cIbSGmYxwZOc2sNnxZ0hsQ\"} />\r\n          </div>\r\n        </ReactMapGL>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n//получение из стора нужных в данном компоненте элементов. они придут через пропсы в этот компонент\r\nconst getDataFromStore = store => ({\r\n\r\n  viewport: store.viewport,\r\n})\r\n\r\n//создание экшенов, которые нужны в этом компоненте. они придут сюда через пропсы.\r\nconst setDataToStore = dispatch => ({\r\n\r\n  changeViewport: (changedViewport) => dispatch(changeViewport(changedViewport)),\r\n  fetchWeatherData: () => dispatch(fetchWeatherData())\r\n})\r\n\r\nexport default connect(getDataFromStore, setDataToStore)(Map);","export function getWeather(lat, lon) {\r\n\r\n    const appid = \"c3c29158ae79eb1c9b2ad2c30aabafd1\", // id аккаунта для запросов\r\n        units = \"metric\", //система измерения\r\n        weatherType = \"forecast\"; // прогноз на несколько дней, weather на текущий момент\r\n\r\n    // возвращается запрос, который после удачного выполнения переводит ответ из json в объект.\r\n    // lat и lon - координаты места на карте для запроса по ним погоды \r\n    return fetch(\r\n        `https://api.openweathermap.org/data/2.5/${weatherType}?lat=${lat}&lon=${lon}&APPID=${appid}&units=${units}`\r\n        ,\r\n        {\r\n            method: \"GET\",\r\n            headers: {\r\n                \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\",\r\n                \"accept\": \"application/json\",\r\n            },\r\n            mode: \"cors\",\r\n        })\r\n        .then(result => result.json());\r\n};","import { call, put, takeLatest, select } from 'redux-saga/effects';\r\nimport { c } from './Actions';\r\nimport { getWeather } from \"../Components/ServerRequest\";\r\n\r\n//тут комменты скорее для себя\r\n//при вызове экшена \"c.FETCH_WEATHER_DATA\" вотчер реагирует и запускает \"fetchWeatherDataAsync\"\r\nexport function* watchFetchWeatherData() {\r\n    yield takeLatest(c.FETCH_WEATHER_DATA, fetchWeatherDataAsync);\r\n};\r\n\r\n//по очереди выполняются yield-команды в генераторе\r\nfunction* fetchWeatherDataAsync() {\r\n    try {\r\n        //из стора забираются нужные значения через select\r\n        const latitude = yield select(state => state.viewport.latitude),\r\n            longitude = yield select(state => state.viewport.longitude);\r\n        //через call(функция, аргумент, аргумент) вызывается запрос на сервер. результат возвращается в data\r\n        const data = yield call(getWeather, latitude, longitude);\r\n        //через put вызывается action в редьсере, минуя экшены. то есть сама сага запускает исполнение в редьюсере\r\n        yield put({ type: c.UPDATE_WEATHER_DATA, weatherData: data });\r\n\r\n    } catch (error) {\r\n        //на случай, если возникнет ошибка в процессе выполнения саги\r\n        yield console.log(\"Error on getting weather data\", error);\r\n    }\r\n}\r\n","import React, { Component } from 'react';\nimport './App.css';\nimport Map from './Components/Map';\nimport { Provider } from 'react-redux';\nimport { createStore, applyMiddleware } from 'redux';\nimport createSagaMiddleware from 'redux-saga';\nimport { mapReducer } from './Redux/Reducer';\nimport {watchFetchWeatherData} from \"./Redux/Saga\";\n\n\nconst sagaMiddleware = createSagaMiddleware();\nconst store = createStore(\n  mapReducer,\n  applyMiddleware(sagaMiddleware)\n);\n\nsagaMiddleware.run(watchFetchWeatherData);\n\nclass App extends Component {\n  \n  render() {\n    return (\n      <Provider store={store}>\n        <div className=\"App\">\n          <Map />\n        </div>\n      </Provider>\n    );\n  }\n}\n\nexport default App;\n","import { c } from './Actions';\r\n\r\nexport function mapReducer(oldState, action) {\r\n\r\n    switch (action.type) {\r\n\r\n        case c.CHANGE_VIEWPORT: {\r\n            const updatedState = {...oldState, viewport: action.viewport};\r\n            return updatedState;\r\n        }\r\n\r\n        case c.CHANGE_SELECTED_DATE: {\r\n            const updatedState = {...oldState, selectedDayForWeather: action.selectedDayForWeather, selectedWordForWeather: action.selectedWordForWeather };\r\n            return updatedState;\r\n        }       \r\n\r\n        case c.UPDATE_WEATHER_DATA: {\r\n            const updatedState = {...oldState, weatherData: action.weatherData};\r\n            return updatedState;\r\n        }      \r\n\r\n        default:\r\n            if (!!oldState) {\r\n                return oldState;\r\n            };\r\n            return {\r\n                viewport: {\r\n                    width: 500,\r\n                    height: 500,\r\n                    latitude: 37.7577,\r\n                    longitude: -122.4376,\r\n                    zoom: 9.5\r\n                },\r\n                weatherData: {\r\n                    city: {\r\n                        name: undefined,\r\n                    },\r\n                    list: [],\r\n                },\r\n                selectedDayForWeather: 0,\r\n                selectedWordForWeather: \"today\",\r\n            };\r\n    }\r\n};","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}